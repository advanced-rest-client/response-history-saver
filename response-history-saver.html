<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../app-pouchdb/pouchdb.html">
<link rel="import" href="../uuid-generator/uuid-generator.html">
<script>
/**
 * An element that saves requests history in a datastore.
 *
 * This element supports Advanced REST Client project.
 *
 * It handles the `response-ready` event asynchronously and updates both
 * requests history and history data data store.
 *
 * The requests history keeps a daily record of requests made by the application.
 * It keeps record of rhe request data that can be restored lated by the
 * application.
 *
 * The history data keeps record of every request made by the application.
 * It can be used to analyse performance of an API endpoint.
 *
 * ## Data model
 *
 * ### request history
 *
 * Property | Type | Description
 * ----------------|-------------|-------------
 * `_id` | `String` | PouchDB database key. Combination of current day (YYYY-MM-dd) + URI encoded request URL and HTTP method name. Each value is separated with a forward slash (/).
 * `created` | `Number` | Timestamp of a time when the record has been created
 * `updated` | `Number` | Timestamp of a time when the record has been updated for the last time
 * `headers` | `String` | List of request headers as a HTTP header string. Can be empty string
 * `method` | `String` | Can be anything but most probably it is a valid HTTP method name
 * `payload` | `String` | Request body. It is always transformed to string.
 * `url` | `String` | the URL of the request.
 *
 * ### request data
 *
 * Note that payload is always string even if the response body was different type.
 *
 * Property | Type | Description
 * ----------------|-------------|-------------
 * `_id` | `String` | PouchDB database key. Combination of URI encoded request URL, HTTP method name and generated UUID. Each value is separated with a forward slash (/).
 * `timings` | `Object` | Valid HAR 1.2 timings object.
 * `totalTime` | `Number` | Number of milliseconds that took to perform the full request.
 * `created` | `Number` | Timestamp of the entry
 * `request` | `Object` | A request details object (see below).
 * `request.headers` | `String` | HTTP headers string sent to the server.
 * `request.payload` | `String` | HTTP message string set to the server.
 * `request.url` | `String` | Request URL
 * `request.method` | `String` | HTTP method of the request
 * `response` | `Object` | Response details object
 * `response.statusCode` | `Number` | A status code of the response.
 * `response.statusText` | `String` | Status text message. Can be empty or undefined.
 * `response.headers` | `String` | HTTP headers string of the response.
 * `response.payload` | `String` | Response body string.
 * `stats` | `Object` | Request and response basic statistics
 * `stats.request` | `Object` | Request basic statistics
 * `stats.request.headersSize` | `Number` | Request headers size in bytes
 * `stats.request.payloadSize` | `Number` | Request payload size in bytes
 * `stats.response` | `Object` | Response basic statistics
 * `stats.response.headersSize` | `Number` | Response headers size in bytes
 * `stats.response.payloadSize` | `Number` | Response payload size in bytes
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof LogicElements
 */
class ResponseHistorySaver extends Polymer.Element {
  static get is() { return 'response-history-saver'; }

  constructor() {
    super();
    this._afterRequestHandler = this._afterRequestHandler.bind(this);
  }

  connectedCallback() {
    super.connectedCallback();
    window.addEventListener('response-ready', this._afterRequestHandler);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener('response-ready', this._afterRequestHandler);
  }

  /**
   * @return {PouchDB} A PouchDB instance for the history-data store.
   */
  get _dbData() {
    /* global PouchDB */
    return new PouchDB('history-data');
  }
  /**
   * @return {PouchDB} A PouchDB instance for the history-requests store.
   */
  get _dbHistory() {
    return new PouchDB('history-requests');
  }
  /**
   * Handler to the `response-ready` event
   */
  _afterRequestHandler(e) {
    const response = e.detail.response;
    const request = e.detail.request;
    const timings = e.detail.timings;
    // Async so the response can be rendered to the user faster.
    setTimeout(() => this.saveHistory(request, response, timings), 100);
  }
  /**
   * Saves request and response data in history.
   *
   * @param {Object} request ARC request object
   * @param {Object} response ARC response object
   * @param {Object} timings Request timings as HAR 1.2 timings object
   * @return {Promise}
   */
  saveHistory(request, response, timings) {
    return this._saveHistoryData(request, response, timings)
    .then(() => this._updateHistory(request, timings));
  }
  /**
   * Saves history data for history analysis in the data store.
   *
   * @param {Request} request The request object containg information about
   * the request
   * @param {Response} response The response object for the response
   * @param {?Object} eventTimings The timings object as descrived in HAR 1.2 spec. Optional.
   * @return {Promise} A promise resolved when data were inserted to the
   * datastore.
   */
  _saveHistoryData(request, response, eventTimings) {
    const doc = this._createHistoryDataModel(request, response, eventTimings);
    const db = this._dbData;
    return db.put(doc)
    .catch((e) => this._handleException(e));
  }
  // Creates a data store model for `_saveHistoryData`
  _createHistoryDataModel(request, response, eventTimings) {
    const requestHeaders = request.headers;
    const responseHeaders = response.headers;
    const timings = this._computeTimings(eventTimings);
    const totalTime = this._computeTotalTime(timings);
    const requestPayloadSize = this._computePayloadSize(request.payload);
    const responsePayloadSize = this._computePayloadSize(response.payload);
    const requestHeadersSize = this._calculateBytes(requestHeaders);
    const responseHeadersSize = this._calculateBytes(responseHeaders);
    const requestStartTime = this._computeStartTime(eventTimings);
    const url = this._computeHistoryStoreUrl(request.url);
    const id = this._computeHistoryDataId(url, request.method);
    const requestPayload = this._computePayloadString(request.payload);
    const responsePayload = this._computePayloadString(response.payload);

    const doc = {
      _id: id,
      timings: timings,
      totalTime: totalTime,
      created: requestStartTime,
      request: {
        headers: requestHeaders,
        payload: requestPayload,
        url: request.url,
        method: request.method,
      },
      response: {
        statusCode: response.status,
        statusText: response.statusText,
        headers: responseHeaders,
        payload: responsePayload
      },
      stats: {
        request: {
          headersSize: requestHeadersSize,
          payloadSize: requestPayloadSize
        },
        response: {
          headersSize: responseHeadersSize,
          payloadSize: responsePayloadSize
        }
      }
    };
    return doc;
  }
  /**
   * Updates the requests history data store.
   * If the request for given URL and method has been already performed this
   * day then the record in the datastore is updated with new data.
   * Otherwise a new record is created.
   *
   * @param {Request} request The request object.
   * @param {?Object} eventTimings A HAR 1.2 timings object from the response
   * event.
   * @return {Promise} A promise that is resolved then the history object has
   * been updated in the data store.
   */
  _updateHistory(request, eventTimings) {
    const requestStartTime = this._computeStartTime(eventTimings);
    const today = this._getDayToday(requestStartTime);
    const key = today + '/' + encodeURIComponent(request.url) + '/' +
      request.method;
    const requestPayload = this._computePayloadString(request.payload);
    return this._writeHistoryItem(key, request, requestPayload,
      requestStartTime);
  }
  /**
   * Performs a write to the history-request store.
   */
  _writeHistoryItem(key, request, payload, time) {
    const db = this._dbHistory;
    let doc;
    return db.get(key)
    .then((doc) => this._createHistoryInserDocument(doc, key, time, request, payload))
    .catch((e) => {
      if (e.status !== 404) {
        return this._handleException(e);
      }
      return this._createHistoryInserDocument(null, key, time, request, payload);
    })
    .then(function(_doc) {
      doc = _doc;
      return db.put(doc);
    })
    .then((result) => {
      doc._id = result.id;
      doc._rev = result.rev;
      this.dispatchEvent(new CustomEvent('history-object-changed', {
        composed: true,
        bubbles: true,
        detail: {
          id: result.id,
          rev: result.rev,
          item: doc
        }
      }));
      return doc;
    })
    .catch((e) => context._handleException(e));
  }

  _createHistoryInserDocument(doc, key, time, request, payload) {
    doc = doc || {};
    doc._id = doc._id || key;
    doc.created = doc.created || time;
    doc.updated = time;
    doc.headers = request.headers;
    doc.method = request.method;
    doc.payload = payload;
    doc.url = request.url;
    return doc;
  }
  /**
   * Computes a valid timings object as descrived in HAR 1.2 spec.
   *
   * @param {?Object} eventTimings A timings object passed by the response
   * event
   * @return {Object} A valid HAR 1.2 timings object.
   */
  _computeTimings(eventTimings) {
    eventTimings = eventTimings || {};
    const timings = {
      connect: eventTimings.connect || -1,
      receive: eventTimings.receive || -1,
      send: eventTimings.send || -1,
      ssl: eventTimings.ssl || -1,
      wait: eventTimings.wait || -1
    };
    return timings;
  }
  /**
   * Computes a timestamp of the request start time.
   * If timings object provided with the response event contains `startTime`
   * property it will compute timestamp from it. Otherwise it will use
   * current time.
   *
   * @param {?Object} timings Timings object from the response event.
   * @return {Number} Timestamp of the request start.
   */
  _computeStartTime(eventTimings) {
    eventTimings = eventTimings || {};
    return eventTimings.startTime ?
      new Date(eventTimings.startTime).getTime() :
      Date.now();
  }
  /**
   * Computes total time of the request from the timings object.
   *
   * @param {Object} timings A timings object as described in HAR 1.2 spec.
   * @return {Number} Sum of times in the `timings` object. The `-1` values
   * doeasn't adds. It returns `-1` if all values are -1.
   */
  _computeTotalTime(timings) {
    const values = Object.keys(timings).map((key) => timings[key]);
    let total = values.reduce((sum, value) => {
      if (value > -1) {
        return sum + value;
      }
      return sum;
    }, 0);
    if (total === 0) {
      total = -1;
    }
    return total;
  }
  /**
   * Produces valid URL to be used in the history-data store.
   * The URL is stripped from query parameters and hash.
   *
   * @param {String} url A URL to process
   * @return {String}
   */
  _computeHistoryStoreUrl(url) {
    try {
      url = new URL(url);
      url.search = '';
      url.hash = '';
      url = url.toString();
    } catch (e) {}
    if (url) {
      url = url.replace(/\?#/g, '');
    }
    return url;
  }
  /**
   * Computes size of the payload.
   *
   * @param {ArrayBuffer|Blob|String} payload The payload
   * @return {Number} Size of the payload
   */
  _computePayloadSize(payload) {
    if (!payload) {
      return 0;
    }
    if (payload instanceof ArrayBuffer) {
      return payload.byteLength;
    } else if (payload instanceof Blob) {
      return payload.size;
    } else {
      return this._calculateBytes(payload);
    }
  }
  /**
   * Calculates size of the string
   * @param {String} str A string to compute size from.
   * @return {Number} Size of the string.
   */
  _calculateBytes(str) {
    if (!str || !str.length || typeof str !== 'string') {
      return 0;
    }
    let s = str.length;
    for (let i = str.length - 1; i >= 0; i--) {
      const code = str.charCodeAt(i);
      if (code > 0x7f && code <= 0x7ff) {
        s++;
      } else if (code > 0x7ff && code <= 0xffff) {
        s += 2;
      }
      if (code >= 0xDC00 && code <= 0xDFFF) {
        i--; //trail surrogate
      }
    }
    return s;
  }
  /**
   * Computes an ID for the `history-data` datas tore.
   *
   * @param {String} url Request URL stripped from query parameters and
   * the hash.
   * @param {String} method HTTP method name.
   * @return {String} Generated unique for this request data store ID. It uses
   * UUID generator to add some random data to the ID except for the
   * URL and method.
   */
  _computeHistoryDataId(url, method) {
    if (!this.__uuid) {
      this.__uuid = document.createElement('uuid-generator');
    }
    const id = encodeURIComponent(url) + '/' + method + '/' +
      this.__uuid.generate();
    return id;
  }
  /**
   * Computes a payload message as a string.
   *
   * @param {any} input Request or response payload
   * @return {String}
   */
  _computePayloadString(input) {
    let result = '';
    if (!input) {
      return result;
    }
    if (typeof input === 'string') {
      return input;
    }
    if (input instanceof ArrayBuffer) {
      return this._arrayBufferToString(input);
    }
    return result;
  }
  /**
   * Convert ArrayBuffer to readable form
   * @param {ArrayBuffer} buff
   * @returns {String} Converted string
   */
  _arrayBufferToString(buffer) {
    if (!!buffer.buffer) {
      const b = buffer.slice(0);
      buffer = b.buffer;
    }
    if ('TextDecoder' in window) {
      try {
        const decoder = new TextDecoder('utf-8');
        const view = new DataView(buffer);
        return decoder.decode(view);
      } catch (e) {
        return '';
      }
    }
    let str = '';
    try {
      const array = new Uint8Array(buffer);
      for (let i = 0; i < array.length; ++i) {
        str += String.fromCharCode(array[i]);
      }
    } catch (e) {}
    return str;
  }
  /**
   * Setss hours, minutes, seconds and ms to 0 and returns timestamp.
   *
   * @return {Number} Timestamp to the day.
   */
  _getDayToday(timestamp) {
    const d = new Date(timestamp);
    if (isNaN(d.getTime())) {
      throw new Error('Invalid timestamp: ' + timestamp);
    }
    d.setMilliseconds(0);
    d.setSeconds(0);
    d.setMinutes(0);
    d.setHours(0);
    return d.getTime();
  }
  /**
   * Handles exceptions to log message ad throws the same exception
   *
   * @param {Error} e
   */
  _handleException(e) {
    let message;
    if (e instanceof Error) {
      message = e.message;
    } else {
      message = JSON.stringify(e);
    }
    this.dispatchEvent(new CustomEvent('send-analytics', {
      composed: true,
      bubbles: true,
      detail: {
        type: 'exception',
        description: message,
        fatal: true
      }
    }));
    console.error('Url history model', e);
    throw new Error(e.message || e);
  }
}
window.customElements.define(ResponseHistorySaver.is, ResponseHistorySaver);
</script>
